package slidingWindow.maxVowels;

import java.util.*;

public class Solution {
    public int maxVowels(String s, int k) {
        int ans = 0; // 最大の母音の数を格納する変数
        var vowels = Set.of('a', 'e', 'i', 'o', 'u'); // Java 11 の Collection factory メソッドで母音の集合を定義

        // 母音のカウントを管理する winCnt 変数を定義
        for (int i = 0, winCnt = 0; i < s.length(); ++i) {
            // 現在の文字が母音であればカウントをインクリメント
            if (vowels.contains(s.charAt(i))) {
                ++winCnt;
            }

            // この部分のコードは、スライディングウィンドウ法を用いて、効率的に k 文字の連続部分文字列内での母音の最大数を計算するために重要な役割を果たしています。

            // 詳細解説
            // この問題では、k 文字の部分文字列内に含まれる母音の最大数を求めたいとしていますが、単純に k
            // 文字ごとに部分文字列を作成して母音をカウントすると効率が悪くなります。そこで スライディングウィンドウ法 を使うことで、計算量を減らしています。

            // スライディングウィンドウ法の概念
            // スライディングウィンドウ法では、固定長のウィンドウ（ここでは長さ
            // k）を文字列全体にスライドさせていき、ウィンドウ内の状態を更新しながら効率的に母音数を追跡します。ウィンドウを右にスライドさせるとき、次のようにカウントを調整します：

            // 新しい文字をウィンドウに加える：ウィンドウの右端に新しい文字が加わります。その文字が母音ならカウント winCnt を増やします。

            // 古い文字をウィンドウから外す：ウィンドウの左端の文字がウィンドウ外に出たら、その文字が母音の場合は winCnt を減らします。

            // コードの詳細解説
            // この部分に対応するコードは以下です：

            // java
            // コードをコピーする
            // if (i >= k && vowels.contains(s.charAt(i - k))) {
            // --winCnt;
            // }
            // 1. i >= k の条件
            // この条件は、現在のインデックス i が k 以上のとき、つまりウィンドウが k 文字の長さに達しているかどうかを確認しています。
            // もし i が k より小さい場合、ウィンドウはまだ k 未満の長さで、左端の文字を「外す」必要がないので、この処理はスキップされます。
            // 2. vowels.contains(s.charAt(i - k))
            // i - k は現在のウィンドウの左端にある文字のインデックスを指します。
            // i が k 以上のときに、s.charAt(i - k) が母音であるかをチェックします。
            // 母音であれば、winCnt を1減らして、ウィンドウから外れた母音の影響をカウントから除外します。
            // 具体例
            // たとえば、s = "abciiidef"、k = 3 の場合を考えます。

            // 最初の k = 3 文字 "abc" で母音をカウントすると、winCnt = 1 になります（母音は a のみ）。
            // 次にウィンドウを1文字右にスライドして "bci" にします。このとき、a がウィンドウから外れ、i が新しくウィンドウに入ります。winCnt
            // は1のままです。
            // さらに右にスライドして "cii" にします。b が外れても母音ではないので winCnt に影響はなく、右端に入る i によって winCnt
            // が2に増えます。
            // このようにしてウィンドウを動かしていき、常に母音の最大数を追跡していきます。
            // この方法のメリット
            // スライディングウィンドウを使うことで、各文字を1回ずつ処理するだけで済み、計算量が O(n) になります。

            // スライドするウィンドウの長さが k を超えた場合、左端の文字が母音であればカウントをデクリメント
            if (i >= k && vowels.contains(s.charAt(i - k))) {
                --winCnt;
            }
            // 現在の母音数と ans の最大値を更新
            ans = Math.max(winCnt, ans);
        }

        return ans; // 最大の母音の数を返す
    }

    public static void main(String[] args) {
        Solution solution = new Solution();

        String input = "abciiidef";
        int k = 3;

        // maxVowels メソッドを呼び出して結果を出力
        int result = solution.maxVowels(input, k);
        System.out.println("最大の母音数: " + result); // 期待出力は 3
    }
}
