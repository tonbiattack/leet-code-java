package pow;

public class Solution {
    public double myPow(double x, int n) {
        // n が負の数の場合、x の逆数を取り、n を正の数に変換します。
        // 例えば、x^-3 = (1/x)^3 として、同様に計算できるようにするためです。
        if (n < 0) {
            n = -n; // 指数 n を正に変換します
            x = 1 / x; // 基数 x を逆数に変換します
        }

        // 結果を格納する変数 pow を 1 に初期化します。
        // pow には、最終的に x の n 乗が格納されることになります。
        double pow = 1;

        // n が 0 になるまでループを回します。
        // これは、指数 n が完全に 0 になるまで計算を続けるためです。
        while (n != 0) {
            // n の最下位ビットが 1 の場合、現在の x の値を pow に掛けます。
            // n & 1 で n の最下位ビットをチェックしています。
            // n の最下位ビットが 1 ということは、n が奇数であることを示し、
            // 奇数のときは pow に x を掛ける必要があります。
            if ((n & 1) != 0) {
                pow *= x; // pow に現在の x の値を掛け、累乗結果を更新します
            }

            // x の二乗を計算し、次のループでの累乗に備えます。
            // x を二乗することで、指数が偶数分進んだ場合の次のステップの基数を準備します。
            x *= x;

            // n を右に 1 ビットシフトして、次のビットをチェックします。
            // これは、指数 n を半分に減らす操作に相当します。
            // ビットシフトを行うことで、指数の計算回数を削減し、計算を効率化しています。
            n >>>= 1;
        }

        // 計算が終わったら、pow に計算された結果が格納されているので、それを返します。
        return pow;
    }

    public static void main(String[] args) {
        // 例として 2 の 10 乗を計算
        double x = 2.00000;
        int n = 10;
        Solution solution = new Solution();
        // myPow メソッドを呼び出し、結果を出力
        System.out.println(solution.myPow(x, n)); // 1024.0 になるはず
    }
}
